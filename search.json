[{"title":"《DDIA 阅读笔记》其二：数据模型与查询语言","url":"/2020/04/05/《DDIA 阅读笔记》其二：数据模型与查询语言/","content":"\n\n\n*准备陆续把之前写下的阅读和学习笔记搬到博客上，这是其中之一。*\n\n*欢迎批评*\n\n# 第二章 数据模型与查询语言\n\n多数应用程序是由层层叠加的数据模型构建而成的。每一层通过提供一个明确的数据模型来隐藏更低一层的复杂性。例如为开发数据库使用到的API与为使用数据库使用到的API。\n\n## 1. 对象关系不匹配\n\nORM 框架可以减少关系模型与对象模型的转换层的代码量，但不能完全隐藏这两个模型间的的差异。例如，一个人的联系方式可能不止一个，我们可以如何将其存储在关系数据库中？\n\n1. 联系方式单独作为一个表，并将所属人的标识作为其外键。\n2. 得益于 SQL 模型增加了对结构化数据类型、XML 类型和 JSON 类型的支持，我们可以将多值存储在单行内，同时能查询和索引这些文档数据。\n3. 让应用程序来完成将数据编码为 XML 或 JSON 文档的任务，然后将文档数据存储在所属人的文本列中，当应用程序需要其中的数据时不能依靠数据库的查询或索引功能而是自己解析其结构和内容。\n\n相比于关系模型，JSON 更具有局部性。例如，当我们查询一个人的信息时，对于关系模型，我们可能需要进行多次查询或连接多个表，而对于 JSON ，所有信息都在同一个地方。\n\n## 2. 数据规范化\n\n*使用 ID 的好处是，ID 对人类没有任何意义，因而永远不需要改变：ID 可以保持不变，即使它标识的信息发生变化。任何对人类有意义的东西都可能需要在将来某个时候改变——如果这些信息被复制，所有的冗余副本都需要更新。这会导致写入开销，也存在不一致的风险（有些副本被更新了，还有些副本没有被更新）。去除此类重复是数据库规范化（normalization）的关键思想。*\n\n对数据进行规范化需要多对一、多对多的关系，关系模型天生支持该特性，但文档模型天生不支持。多对一、多对多的关系需要连接，但文档模型的树结构没必要支持连接。有的文档型数据库为此提供了连接功能。如果使用没有连接的数据库，就需要在应用程序模拟连接。\n\n## 3. 层次模型、网络模型、关系模型、文档模型\n\n网络模型是层次模型的推导。层次模型的节点只能有一个父节点，网络模型的节点能有多个父节点。这导致了程序员使用网络模型数据库时需要手动选择“访问路径”。\n\n关系模型使用查询优化器自动生成“访问路径”。\n\n文档模型被还原为层次模型。在表示多对一、多对多关系时，文档数据库系统中相关项目都被唯一标识符引用，这个标识符在关系模型中被称作外键，在文档模型中被成为文档引用。该标识符在读取时通过通过连接和后续查询来解析。\n\n## 4. 文档模型中的架构灵活性，模式 VS. 无模式\n\n文档模型有时被称为“无模式（schemaless）”，但这具有误导性。因为在读取数据时我们会假定某种结构--即隐式模式，但该结构不由文档型数据库强制保证。一个更精确的术语是”读时模式（schema-on-read）”--数据结构只有在读时才被解释，相对应的是“写时模式（schema-on-write）”--传统关系模型要求模式明确且 DBMS 要确保所有数据都符合模式。\n\n* 读时模式：没有模式，DBMS 不要求写入的数据与现有数据的结构一致，但数据被读取时应用程序需解释其结构。文档模型便是这一类型，这为文档型数据库带来了灵活性。\n* 写时模式：模式明确，这意味在写入时要验证数据是否符合模式。\n\n例如，当一个实体将一个旧属性拆分为两个属性时，对于文档型数据库，旧的数据不需变动，在应用程序增加对旧数据手动拆分的代码就可以。而对于关系型数据库，需要更改表的模式--这时数据库系统要停机。\n\n## 5. 查询的数据局部性\n\n文档通常以单个连续字符串的形式存储，编码为 JSON、XML 或其二进制变体（例如 MongoDB 的 BSON）。\n\n存储局部性可以避免在插叙时因将数据分割在多个位置而需要的多次索引所花费的磁盘查找时间。\n\n局部性并不只有文档模型在考虑，一些关系型数据库也提供了相关支持。\n\n## 6.文档与关系数据库的融合\n\n现在，PostgreSQL 和 MySQL 等数据库提供了对 JSON 的支持。关系模型和文档模型的混合是数据库发展的一条很好的路线。\n\n## 7. SQL的优势\n\nSQL 相当有限的功能性为数据库提供了更多自动优化的空间。\n\n命令代码很难在多个内核和多个机器之间并行化，因为它指定了指令必须以特定顺序执行。声明式语言更具有并行执行的潜力，因为它们仅指定结果的模式，而不指定用于确定结果的算法。在适当情况下，数据库可以自由使用查询语言的并行实现。\n\n## 8. MapReduce查询\n\nMapReduce 是一个由Google推广的编程模型，用于在多台机器上批量处理大规模的数据。\n\nMapReduce 既不是一个声明式的查询语言，也不是一个完全命令式的查询 API，而是处于两者之间：查询的逻辑用代码片断来表示，这些代码片段会被处理框架重复性调用。它基于 map （也称为 collect ）和 reduce （也称为 fold 或 inject ）函数，两个函数存在于许多函数式编程语言中。\n\n能够在查询中使用 JavaScript 代码是高级查询的一个重要特性，但这不限于 MapReduce，一些 SQL 数据库也可以用 JavaScript 函数进行扩展。\n\n## 9. 小结\n\n新的非关系型 “NoSQL” 数据存储在两个主要方向上存在分歧：\n\n1. 文档数据库的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少。\n2. 图形数据库用于相反的场景：任意事物都可能与任何事物相关联。","tags":["系统设计","数据库设计","DDIA","笔记"]},{"title":"《DDIA 阅读笔记》其一：数据库密集系统设计指标","url":"/2020/04/05/《DDIA 阅读笔记》其一：数据密集型系统设计指标/","content":"\n\n\n*准备陆续把之前写下的阅读和学习笔记搬到博客上，这是其中之一。*\n\n*欢迎批评。*\n\n# 第一章：可靠性、可维护性、可扩展性\n\n## 1.数据密集型应用的标准组件\n\n* 数据库（database）：存储数据\n* 缓存（cache）：记住开销昂贵的操作，以加快读取速度\n* 搜索索引（search indexes）：允许用户按关键字搜索数据，或过滤数据\n* 流处理（stream processing）：向其他进程发送消息，进行异步处理\n* 批处理（batch processing）：定期处理积累的大批量数据\n\n## 2. 可靠性\n\n### - 硬件故障\n\n硬件故障让人想到硬盘崩溃、内存出错、机房断电。\n\n硬件冗余是一种增加容错率解决方案，例如由硬盘组成的 RAID、双路电源、热插拔 CPU 等。\n\n### - 软件错误\n\n比起硬件故障，系统性错误往往是牵一发而动全身，例如级联错误。\n\n### - 人为错误\n\n## 3. 可扩展性\n\n### - 描述负载的参数\n\n扇出描述用来在事务处理系统中为了服务一个传入请求而需要执行其他服务的请求数量。\n\n在推特的例子中，每个用户粉丝数的分布（可能按这些用户的发推频率来加权）是探讨可扩展性的一个关键负载参数，因为它决定了扇出负载。\n\n推特逐步转向了两种方法的混合。大多数用户发的推文会被扇出写入其粉丝主页时间线缓存中。但是少数拥有海量粉丝的用户（即名流）会被排除在外。当用户读取主页时间线时，分别地获取出该用户所关注的每位名流的推文，再与用户的主页时间线缓存合并。\n当负载被描述好，就可以研究当负载增加时会发生什么。\n\n### - 描述性能的指标\n\n性能指标:\n\n* 吞吐量\n* 平均响应时间\n* 百分点位\n\n平均响应时间在很多场景是没有意义的。\n\n百分位点通常用于服务级别目标（SLO, service level objectives）和服务级别协议（SLA,service level agreements），即定义服务预期性能和可用性的合同。 SLA 可能会声明，如果服务响应时间的中位数小于200毫秒，且99.9百分位点低于1秒，则认为服务工作正常（如果响应时间更长，就认为服务不达标）。这些指标为客户设定了期望值，并允许客户在 SLA 未达标的情况下要求退款。\n\n### - 应对负载的方法\n\n纵向扩展（垂直扩展）\n横向扩展（水平扩展）\n\n弹性系统 VS. 手动扩展\n\n* 当负载极难预测时，弹性系统比手工扩展更有用。\n* 手工扩展系统更简单，并且意外操作更少。\n\n一个良好适配应用的可扩展架构，是围绕着假设（assumption）建立的：哪些操作是常见的？哪些操作是罕见的？这就是所谓负载参数。\n\n## 4. 可维护性\n\n软件系统设计原则\n\n* 可操作性\n* 简单性: 管理复杂度\n* 可演化性","tags":["系统设计","DDIA","笔记"]},{"title":"比较非静态字段与ThreadLocal：理解ThreadLocaL及其应用场景","url":"/2020/03/17/比较非静态字段与ThreadLocal：理解ThreadLocal及其应用场景/","content":"\n### 前言\n\n本文适用于了解 ThreadLocal 的 API 但对于其应用场景难以理解或一知半解的读者，所以本文不会赘述 ThreadLocal 的 API，因为他的 API 很简单且已经有了许多解释其的文章。\n\n### 正文\n\nJDK 1.8 里 ThreadLocal 类源码的第一句注释就是这么一句话：\n\n> This class provides thread-local variables.  \n\n这句话的翻译是： **ThreadLocal 提供线程本地的变量**。ThreadLocal 的作用正是围摇着这句话而发挥的。\n\n思考一个问题：除了 ThreadLocal 还有什么能提供线程本地的变量？\n\n一个类的非静态字段属于该类的实例的本地变量，一个线程可以理解为一个 Thread 类或其子类的实例，那么 Thread 类或其子类的非静态字段就属于由其构造的线程（实例）的本地的变量。\n\n根据以上理解不难发现，ThreadLocal 可以提供 Thread 子类的非静态字段作为本地变量的作用，亦即 **ThreadLocal 能够替代一部分线程类的非静态字段**。代码清单-1 和代码清单-2 可以体现这一点。\n\n代码清单-1 使用了非静态字段存储线程的名称，代码清单-2 则使用了一个 ThreadLocal 实例达成存储线程名称的作用。 两者的运行结果是一致的，可以说**一个 ThreadLocal 实例为使用他的线程们添加了额外的一个非静态字段**，与预期结果也是一致的，他们都发挥了作为线程本地变量的作用，他们都没有破坏线程安全性。\n\n```java\n\t/* 代码清单-1 */\n\tprivate static class MyThread extends Thread {\n        private String name;\n\n        public MyThread(int i) {\n            this.name = \"Thread-\" + i;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(this.name);\n        }\n    }\n\n    public static void main(String[] args) {\n        int threads = 3;\n        for (int i = 0; i < threads; i++) {\n            new MyThread(i).start();\n        }\n    }\n\n    /*\n        运行结果：\n        Thread-0\n        Thread-1\n        Thread-2\n    */\n    \n```\n\n```java\n    /* 代码清单-2 */\n\tpublic static void main(String[] args) {\n        ThreadLocal<String> name = new ThreadLocal<>();\n        int threads = 3;\n        ExecutorService executor = Executors.newFixedThreadPool(threads);\n        try {\n            for (int i = 0; i < threads; i++) {\n                int finalI = i;\n                executor.execute(() -> {\n                    name.set(\"Thread-\" + finalI);\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(name.get());\n                });\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n\n    /*\n        运行结果：\n        Thread-0\n        Thread-1\n        Thread-2\n    */\n```\n\n那么为什么以及什么情况下我们要用 ThreadLocal 替代非静态字段？\n\n对比代码清单-1 和代码清单-2 可以知道一些答案。众所周知，为了在不能修改一个类本身的情况下的给一个类添加字段，我们要么使用继承创造语法上的子类，要么使用组合创造行为上的子类，代码清单-1 是继承的完美体现，而代码清单-2 是组合的另类体现。组合没有继承那么强的侵入性，代码清单-1 只能手动创建线程，而这是不被提倡的，代码清单-2 则能利用线程池的优势。\n\n代码清单-1 和 代码清单-2 的场景是比较简单的，现实场景相对复杂很多。\n\n下面再举一个案例。\n\n日志经常被使用来记录程序的运行情况，假如有一个日志类用于将各种信息记录于文件中，现在将其运用于记录线程的运行信息，要求每个线程的信息被记录于属于他的独立的文件中。关于该类的实现，有两种想法：1）该类是线程安全的，即使用者不需要担心他会引入线程安全问题，2）该类不是线程安全的，即使用者需要解决由他引入的线程安全问题。\n\n代码清单-3 是第2类实现，Log 类不保证线程安全性，为了弥补这一点，让每个使用他的线程都有一个他的实例。注意到，Log 类侵入了本来用于实现其他业务逻辑的线程类，增加了耦合度。代码清单-4 利用 ThreadLocal 提供了更好的实现。\n\n```java\n/* 代码清单-3 */\npublic class Log {\n    private PrintWriter writer;\n\n    public ThreadSpecificLog(String fileName) throws IOException {\n        writer = new PrintWriter(new FileWriter(fileName));\n    }\n\n    public void println(String s) {\n        writer.println(s);\n    }\n\n    public void close() {\n        writer.close();\n    }\n}\n\npublic class MyThread extends Thread {\n\n    private Log log;\n\n    public MyThread(String name) throws IOException {\n        super(name);\n        log = new Log(name + \"-log.txt\");\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; i < 10; i++) {\n                log.println(getName() + \" \" + i);\n                Thread.sleep(200);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            log.close();\n        }\n    }\n}\n```\n\n```java\n/* 代码清单-4 */\npublic class ConcurrentLog {\n    private static final ThreadLocal<Log> log = new ThreadLocal<>();\n\n    public static void println(String s) throws IOException {\n        getLocalLog().println(s);\n    }\n\n    public static void close() throws IOException {\n        println(\"End of Log\");\n        getLocalLog().close();\n    }\n\n    private static Log getLocalLog() throws IOException {\n        Log localLog = log.get();\n        if(localLog == null) {\n            localLog = new Log(Thread.currentThread().getName() + \"-log.txt\");\n            log.set(localLog);\n        }\n        return localLog;\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        int threads = 3;\n        ExecutorService executor = Executors.newFixedThreadPool(threads);\n        try {\n            for (int i = 0; i < threads; i++) {\n                int finalI = i;\n                executor.execute(() -> {\n                    Thread.currentThread().setName(\"Thread-\"+ finalI);\n                    try {\n                        for (int j = 0; j < 10; j++) {\n                            ConcurrentLog.println(Thread.currentThread().getName() + \": \" + j);\n                            Thread.sleep(200);\n                        }\n                    } catch (InterruptedException | IOException e) {\n                        e.printStackTrace();\n                    } finally {\n                        try {\n                            ConcurrentLog.close();\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n```\n\n代码清单-4 中的 ConcurrentLog 类是第1类实现，为 Log 提供了线程安全性，增加了一层抽象，为线程提供了更好的接口，减少了与线程的耦合，使线程更能专注于实现自己的业务逻辑。从 测试类可以体现出来，ConcurrentLog 与线程的耦合度很低，他不会导致线程需要手动创建的情况发生，线程池内的线程的运用信息也能被记录。\n\n### 总结\n\n当需要使用非静态字段来提供线程安全性时，可以考虑使用 ThreadLocal 类来代替。 ThreadLocal 相当于不在 Thread 子类内声明的非静态字段，与后者相比他更加灵活，他可以在外部被声明然后在更多的地方使用。最后提一点：**他不是天生线程安全的**，就像不同线程的非静态字段可以引用同一实例来在多线程中共享数据一样，一个 ThreadLocal 实例在不同线程里也可以存储同一实例，毕竟 **ThreadLocal 提供的是类似变量的功能**，他可以在多个线程内引用同一个实例，这通常意味着 bug， 因为ThreadLocal 的语义被破坏了，何必在这种场景下使用 ThreadLocal 呢。","tags":["Java 并发"]},{"title":"函数式编程学习之路：Mit-Scheme 在 Ubuntu16.04 下的环境配置","url":"/2019/03/16/函数式编程学习之路:Mit-Scheme在Ubuntu16.04下的环境配置/","content":"## 前言\n最近，为了学习函数式编程，我开始看 MIT 的视频公开课 - **《计算机程序的构造和解释》**（使用的教程是著名的**SICP**）。为了与课程同步，我需要学习 **scheme** 这门函数式编程语言，这是我学习的第一门以函数式编程为主的语言。首先我要开始学习如何配置这门语言的环境，为了加深记忆以及方便以后的复用而尽量避免再次花时间在搜索引擎上，我把我了解、学习到的内容总结到这篇文章里。\n\n## 安装\n得益于 Ubuntu 上早有编译好的包，可以直接使用 `sudo apt-get install mit-scheme` 一步到位。这种方法最简单但安装好的解释器可能不是最新版的，也可能不是想要的版本，对于版本有要求的话，需要访问 MIT-Scheme 的主页下载适用的版本，然后编译安装。\n\n## 在 MIT-Scheme 解释器内解释或编译运行程序\n在终端输入 `mit-scheme` 或 `scheme` 会进入解释器环境内，这时可以输入 Scheme 语句然后执行，我的解释器环境如下图所示：\n\n![](https://miao.su/images/2019/03/16/2019-03-1609-40-14mit-scheme96b32.png)\n\n输入语句然后执行：\n\n![](https://miao.su/images/2019/03/16/2019-03-1609-59-48mit-scheme02b10c4.png)\n\n如果有一个文件名为 add.scm 、 内容为 `(* 3 4 5)` 的Scheme程序，如何执行？\n\n1. 在 mit-scheme 解释器里输入命令 `(cf \"add\")` 可以编译源码:\n\n    ![](https://miao.su/images/2019/03/16/2019-03-1610-10-54mit-scheme0359bc5.png)\n2. 再输入命令 `(load \"add\")` 会运行编译好的程序:\n\n    ![](https://miao.su/images/2019/03/16/2019-03-1610-13-00mit-schmem0489817.png)\n\n## 使用 MIT-Scheme 直接解释执行程序\n上述方法有一点麻烦，其实有更简单的方式在终端上执行Scheme程序，我们可以利用 shell 的重定向能力，在终端输入 `scheme < add.scm`，出现如下提示：\n\n![](https://miao.su/images/2019/03/16/2019-03-1610-21-00mit-scheme0552454.png)\n\n## 在 Visual Studio Code 上编写和运行Scheme源码\n\n1. 首先需要安装 **vscode-scheme** 和 **Code Runner** 这两个插件。第一个插件提供了代码高亮和补全等功能，让我们在编写 Scheme 时更舒服，第二个插件让我们能一键运行 Scheme 程序。\n2. 配置 Code Runner。在 vscode 的配置里搜索 `executorMapByFileExtension`，点击 **在settings.json中编辑** 打开 settings.json,如果发现没有名为 `code-runner.executorMapByFileExtension` 的字段的话，那就添加它，vscode会自动生成默认的配置，然后在该字段下添加一行：`\".scm\": \"scheme <\"`，保存后如下所示：\n\n    ![](https://miao.su/images/2019/03/16/2019-03-1610-46-24mit-scheme069fc73.png)\n3. 代码写完保存后直接按 Code Runner 的快捷键 Ctrl+Alt+N 即可运行","tags":["函数式编程","环境配置"]}]