[{"title":"比较非静态字段与ThreadLocal：完全理解ThreadLocaL及其应用场景","url":"/2020/03/17/比较非静态字段与ThreadLocal：完全理解ThreadLocal及其应用场景/","content":"\n### 前言\n\n本文适用于了解 ThreadLocal 的 API 但对于其应用场景难以理解或一知半解的读者，所以本文不会赘述 ThreadLocal 的 API，因为他的 API 很简单且已经有了许多解释其的文章。\n\n### 正文\n\nJDK 1.8 里 ThreadLocal 类源码的第一句注释就是这么一句话：\n\n> This class provides thread-local variables.  \n\n这句话的翻译是： **ThreadLocal 提供线程本地的变量**。ThreadLocal 的作用正是围摇着这句话而发挥的。\n\n思考一个问题：除了 ThreadLocal 还有什么能提供线程本地的变量？\n\n一个类的非静态字段属于该类的实例的本地变量，一个线程可以理解为一个 Thread 类或其子类的实例，那么 Thread 类或其子类的非静态字段就属于由其构造的线程（实例）的本地的变量。\n\n根据以上理解不难发现，ThreadLocal 可以提供 Thread 子类的非静态字段作为本地变量的作用，亦即 **ThreadLocal 能够替代一部分线程类的非静态字段**。代码清单-1 和代码清单-2 可以体现这一点。\n\n代码清单-1 使用了非静态字段存储线程的名称，代码清单-2 则使用了一个 ThreadLocal 实例达成存储线程名称的作用。 两者的运行结果是一致的，**可以说 一个 ThreadLocal 实例为使用他的线程们添加了额外的一个非静态字段**，与预期结果也是一致的，他们都发挥了作为线程本地变量的作用，他们都没有破坏线程安全性。\n\n```java\n\t/* 代码清单-1 */\n\tprivate static class MyThread extends Thread {\n        private String name;\n\n        public MyThread(int i) {\n            this.name = \"Thread-\" + i;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(this.name);\n        }\n    }\n\n    public static void main(String[] args) {\n        int threads = 3;\n        for (int i = 0; i < threads; i++) {\n            new MyThread(i).start();\n        }\n    }\n\n    /*\n        运行结果：\n        Thread-0\n        Thread-1\n        Thread-2\n    */\n    \n```\n\n```java\n    /* 代码清单-2 */\n\tpublic static void main(String[] args) {\n        ThreadLocal<String> name = new ThreadLocal<>();\n        int threads = 3;\n        ExecutorService executor = Executors.newFixedThreadPool(threads);\n        try {\n            for (int i = 0; i < threads; i++) {\n                int finalI = i;\n                executor.execute(() -> {\n                    name.set(\"Thread-\" + finalI);\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(name.get());\n                });\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n\n    /*\n        运行结果：\n        Thread-0\n        Thread-1\n        Thread-2\n    */\n```\n\n那么为什么以及什么情况下我们要用 ThreadLocal 替代非静态字段？\n\n对比代码清单-1 和代码清单-2 可以知道一些答案。众所周知，为了在不能修改一个类本身的情况下的给一个类添加字段，我们要么使用继承创造语法上的子类，要么使用组合创造行为上的子类，代码清单-1 是继承的完美体现，而代码清单-2 是组合的另类体现。组合没有继承那么强的侵入性，代码清单-1 只能手动创建线程，而这是不被提倡的，代码清单-2 则能利用线程池的优势。\n\n代码清单-1 和 代码清单-2 的场景是比较简单的，现实场景相对复杂很多。\n\n下面再举一个案例。\n\n日志经常被使用来记录程序的运行情况，假如有一个日志类用于将各种信息记录于文件中，现在将其运用于记录线程的运行信息，要求每个线程的信息被记录于属于他的独立的文件中。关于该类的实现，有两种想法：1）该类是线程安全的，即使用者不需要担心他会引入线程安全问题，2）该类不是线程安全的，即使用者需要解决由他引入的线程安全问题。\n\n代码清单-3 是第2类实现，Log 类不保证线程安全性，为了弥补这一点，让每个使用他的线程都有一个他的实例。注意到，Log 类侵入了本来用于实现其他业务逻辑的线程类，增加了耦合度。代码清单-4 利用 ThreadLocal 提供了更好的实现。\n\n```java\n/* 代码清单-3 */\npublic class Log {\n    private PrintWriter writer;\n\n    public ThreadSpecificLog(String fileName) throws IOException {\n        writer = new PrintWriter(new FileWriter(fileName));\n    }\n\n    public void println(String s) {\n        writer.println(s);\n    }\n\n    public void close() {\n        writer.close();\n    }\n}\n\npublic class MyThread extends Thread {\n\n    private Log log;\n\n    public MyThread(String name) throws IOException {\n        super(name);\n        log = new Log(name + \"-log.txt\");\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; i < 10; i++) {\n                log.println(getName() + \" \" + i);\n                Thread.sleep(200);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            log.close();\n        }\n    }\n}\n```\n\n```java\n/* 代码清单-4 */\npublic class ConcurrentLog {\n    private static final ThreadLocal<Log> log = new ThreadLocal<>();\n\n    public static void println(String s) throws IOException {\n        getLocalLog().println(s);\n    }\n\n    public static void close() throws IOException {\n        println(\"End of Log\");\n        getLocalLog().close();\n    }\n\n    private static Log getLocalLog() throws IOException {\n        Log localLog = log.get();\n        if(localLog == null) {\n            localLog = new Log(Thread.currentThread().getName() + \"-log.txt\");\n            log.set(localLog);\n        }\n        return localLog;\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        int threads = 3;\n        ExecutorService executor = Executors.newFixedThreadPool(threads);\n        try {\n            for (int i = 0; i < threads; i++) {\n                int finalI = i;\n                executor.execute(() -> {\n                    Thread.currentThread().setName(\"Thread-\"+ finalI);\n                    try {\n                        for (int j = 0; j < 10; j++) {\n                            ConcurrentLog.println(Thread.currentThread().getName() + \": \" + j);\n                            Thread.sleep(200);\n                        }\n                    } catch (InterruptedException | IOException e) {\n                        e.printStackTrace();\n                    } finally {\n                        try {\n                            ConcurrentLog.close();\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n```\n\n代码清单-4 中的 ConcurrentLog 类是第1类实现，为 Log 提供了线程安全性，增加了一层抽象，为线程提供了更好的接口，减少了与线程的耦合，使线程更能专注于实现自己的业务逻辑。从 测试类可以体现出来，ConcurrentLog 与线程的耦合度很低，他不会导致线程需要手动创建的情况发生，线程池内的线程的运用信息也能被记录。\n\n### 总结\n\n当需要使用非静态字段来提供线程安全性时，可以考虑使用 ThreadLocal 类来代替。 ThreadLocal 相当于不在 Thread 子类内声明的非静态字段，与后者相比他更加灵活，他可以在外部被声明然后在更多的地方使用。但他不是天生线程安全的，就像不同线程的非静态字段可以引用同一实例来在多线程中共享数据一样，一个 ThreadLocal 实例在不同线程里也可以存储同一实例，毕竟 ThreadLocal 提供的是类似变量的功能，他可以在多个线程内引用同一个实例，这通常意味着 bug， 因为ThreadLocal 的语义被破坏了，何必在这种场景下使用 ThreadLocal 呢。","tags":["Java 并发"]},{"title":"函数式编程学习之路：Mit-Scheme 在 Ubuntu16.04 下的环境配置","url":"/2019/03/16/函数式编程学习之路:Mit-Scheme在Ubuntu16.04下的环境配置/","content":"## 前言\n最近，为了学习函数式编程，我开始看 MIT 的视频公开课 - **《计算机程序的构造和解释》**（使用的教程是著名的**SICP**）。为了与课程同步，我需要学习 **scheme** 这门函数式编程语言，这是我学习的第一门以函数式编程为主的语言。首先我要开始学习如何配置这门语言的环境，为了加深记忆以及方便以后的复用而尽量避免再次花时间在搜索引擎上，我把我了解、学习到的内容总结到这篇文章里。\n\n## 安装\n得益于 Ubuntu 上早有编译好的包，可以直接使用 `sudo apt-get install mit-scheme` 一步到位。这种方法最简单但安装好的解释器可能不是最新版的，也可能不是想要的版本，对于版本有要求的话，需要访问 MIT-Scheme 的主页下载适用的版本，然后编译安装。\n\n## 在 MIT-Scheme 解释器内解释或编译运行程序\n在终端输入 `mit-scheme` 或 `scheme` 会进入解释器环境内，这时可以输入 Scheme 语句然后执行，我的解释器环境如下图所示：\n\n![](https://miao.su/images/2019/03/16/2019-03-1609-40-14mit-scheme96b32.png)\n\n输入语句然后执行：\n\n![](https://miao.su/images/2019/03/16/2019-03-1609-59-48mit-scheme02b10c4.png)\n\n如果有一个文件名为 add.scm 、 内容为 `(* 3 4 5)` 的Scheme程序，如何执行？\n\n1. 在 mit-scheme 解释器里输入命令 `(cf \"add\")` 可以编译源码:\n\n    ![](https://miao.su/images/2019/03/16/2019-03-1610-10-54mit-scheme0359bc5.png)\n2. 再输入命令 `(load \"add\")` 会运行编译好的程序:\n\n    ![](https://miao.su/images/2019/03/16/2019-03-1610-13-00mit-schmem0489817.png)\n\n## 使用 MIT-Scheme 直接解释执行程序\n上述方法有一点麻烦，其实有更简单的方式在终端上执行Scheme程序，我们可以利用 shell 的重定向能力，在终端输入 `scheme < add.scm`，出现如下提示：\n\n![](https://miao.su/images/2019/03/16/2019-03-1610-21-00mit-scheme0552454.png)\n\n## 在 Visual Studio Code 上编写和运行Scheme源码\n\n1. 首先需要安装 **vscode-scheme** 和 **Code Runner** 这两个插件。第一个插件提供了代码高亮和补全等功能，让我们在编写 Scheme 时更舒服，第二个插件让我们能一键运行 Scheme 程序。\n2. 配置 Code Runner。在 vscode 的配置里搜索 `executorMapByFileExtension`，点击 **在settings.json中编辑** 打开 settings.json,如果发现没有名为 `code-runner.executorMapByFileExtension` 的字段的话，那就添加它，vscode会自动生成默认的配置，然后在该字段下添加一行：`\".scm\": \"scheme <\"`，保存后如下所示：\n\n    ![](https://miao.su/images/2019/03/16/2019-03-1610-46-24mit-scheme069fc73.png)\n3. 代码写完保存后直接按 Code Runner 的快捷键 Ctrl+Alt+N 即可运行","tags":["函数式编程","环境配置"]}]